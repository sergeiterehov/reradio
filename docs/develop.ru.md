# Как добавить драйвер

## Разверни проект локально

Для разработки потребуется среда выполнения [NodeJS 24+](https://nodejs.org/en/download). Или можно воспользоваться бесплатным Codespace прямо на GitHub, тогда ничего кроме браузера не потребуется.

- Сделай форк репозитория на GitHub
- Скачай git репозиторий проекта
- Установи зависимости командой `npm ci`
- Запусти локальный сервер командой `npm run dev`
- Теперь можно открыть в браузере [localhost:5173](http://localhost:5173/)

Обязательно используй ESLint, и периодически форматируй код. Желательно включить форматирование на сохранение. Плохо отформатированный код не будет принят.

## Создай файл драйвера

Все драйвера находятся в папке [src/drivers](../src/drivers).

Создай новый файл с именем типа станции. Будь лаконичен в названии: зачастую хватает только названия модели, посмотри, как названы другие драйвера.

Если ты хочешь добавить сразу линейку устройств, которые незначительно отличаются в реализации, можно использовать подход с наследованием и переопределением. В этом случай все сразу несколько драйверов может находится в одном файле.

Не пытайся разделить драйвер на несколько файлов. Да, скорей всего у тебя получится один большой файл, и это не страшно. Используй возможности IDE для сворачивания блоков кода и навигации по структуре.

Если реализации драйверов отличаются сильно, не используй наследование. Не пытайся вытащить отдельные методы или справочники из других драйверов. Это повышает связность кода и ухудшает его понятность. Просто скопируй нужный код в новый драйвер.

## Реализация

Драйвер - это класс, который наследуется от `Radio` ([src/drivers/_radio.ts](../src/drivers/_radio.ts)).

Для подключения драйвера, нужно добавить его в `Library` ([src/drivers/_library.ts](../src/drivers/_library.ts)).

В нем есть всего несколько методов и свойств, которые нужно реализовать. Очень важно изолировать все состояние станции и процессов драйвера внутри экземпляра класса.

- `static override Info: RadioInfo` \
Содержит информацию о производителе, модели и уникальный идентификатор драйвера.
- `override ui()` \
Возвращает декларативное описание интерфейса. Пока настройки не прочитаны, нужно возвращать пустой список полей. Допустимо возвращать label-поля, если нужно показать крайне важную информацию до начала использования драйвера.
- `override async load(snapshot: Buffer, version: number)` \
Загружает образ настроек. Версия понадобится, когда ты будешь менять структуру выгружаемых настроек. Но скорей всего, это не потребуется. \
Образ может иметь любую структуру, не обязательно ту же, что и в самой станции. Это может быть и JSON, но для импорта/экспорта используется массив байт.
- `override async upload()` \
Этот метод должен вернуть снимок. По сути, выход этого метода будет подаваться на вход методу `load()`. По умолчанию используй `version: 0`.
- `override async read()` \
Читает настройки станции и сохраняет их в экземпляре класса. Как именно хранятся настройки - не регламентировано, но можно отталкиваться от заготовки ниже.
- `override async write()` \
Записывает настройки из экземпляра класса в станцию.

Если обмен идет через Serial Port, можно использовать вспомогательный объект `serial`, он упрощает взаимодействие с Web Serial API. Если нужен какой то иной протокол взаимодействия со станцией, можно и нужно реализовать его самостоятельно.

Будьте крайне внимательны в асинхронном коде. Не забывайте про `async/await`, избегайте `callback` паттерна, если это возможно. Оборачивайте критические участки в `try/catch`.

Для прерывания процесса чтения/запили/загрузки/выгрузки используйте исключения.

### Прогресс и очистка

Обязательно выставляй значения прогресса при чтении и записи настроек через `dispatch_progress()`. Это очень важно для пользователя. Абсолютная точность прогресса не нужна. Важней его регулярное обновление и относительное соответствие этапу операции.

Перед началом чтения обязательно очищай состояние и UI.

- `dispatch_ui_change()` нужно вызвать для синхронизации набора полей, который возвращает `ui()` с текущем состоянием драйвера. Например, после очистки образа или после его прочтения.
- `dispatch_ui()` вызывается при изменении значений внутри настроек. Если используется `create_mem_mapper()`, то ему можно передать этот метод для автоматического обновления интерфейса при изменении через структуру данных.

## common_ui и мультиязычность

Изучи библиотеку готовых настроек в [src/utils/common_ui](../src/utils/common_ui). Используй их, это нужно чтобы интерфейс был целостным и понятным при переходе между станциями.

Если ты не найдешь нужный элемент в библиотеке, или ее описание не будет подходить твоей настройке:
- Очень специфичные для станции настройки можно реализовать на месте. Опиши их подходящим `UI.Fields`. Все текстовые названия и подсказки пиши только по английски. Если какой то текст есть в файле локализации, используй его. Например `t("off")`/`t("on")`.
- Настройки, которые точно встречаются в других станциях можно и нужно добавлять в библиотеку `common_ui`. В этом случае все названия и подсказки должны быть локализованы. Должна быть возможность кастомизировать параметры поля. Например, если это выбор из диапазон, то его границы должны быть настраиваемым.

## Заготовка драйвера

```ts
import { Buffer } from "buffer";
import { Radio, type RadioInfo } from "./_radio";
import { create_mem_mapper } from "@/utils/mem";
import { common_ui } from "@/utils/common_ui";
import { serial } from "@/utils/serial";
import type { UI } from "@/utils/ui";
import { t } from "i18next";

export class NewRadio extends Radio {
  static override Info: RadioInfo = {
    id: "shot_driver_id", // TODO: Короткий уникальный идентификатор драйвера.
    vendor: "Производитель",
    model: "Название-модели",
  };

  protected _parse(img: Buffer) {
    const m = create_mem_mapper(img, this.dispatch_ui);

    return {
      // MARK: Channels
      ...m.seek(0x0000).skip(0, {}),

      channels: m.array(999, () =>
        m.struct(() => ({
          freq: m.u32(),
        })),
      ),

      // MARK: Settings
      ...m.seek(0x1000).skip(0, {}),

      settings: {
        squelch_level: m.u8(),
      },
    };
  }

  override ui(): UI.Root {
    if (!this._mem) return { fields: [] };

    const { channels, settings } = this._mem;

    return {
      fields: [
        {
          ...common_ui.channels({ size: channels.length }),
          freq: {
            min: 400_000_000,
            max: 470_000_000,
            get: (i) => channels[i].freq.get(),
            set: (i, val) => channels[i].freq.set(val),
          },
        },

        common_ui.sql(settings.squelch_level, { min: 0, max: 9 }),
      ],
    };
  }

  protected _img?: Buffer;
  protected _mem?: ReturnType<typeof this._parse>;

  override async load(snapshot: Buffer, version: number) {
    this._img = snapshot;
    this._mem = this._parse(this._img);
    this.dispatch_ui_change();
  }

  override async upload() {
    if (!this._img) throw new Error("No data");
    return { version: 0, snapshot: Buffer.from(this._img) };
  }

  override async read() {
    this.dispatch_progress(0);

    await serial.begin({ baudRate: 9600 });
    await serial.clear();

    this._img = undefined;
    this._mem = undefined;
    this.dispatch_ui_change();

    // TODO: Реализуй чтение со станции. Не забудь про this.dispatch_progress(...);
    await serial.write(Buffer.from([0x01, 0x02]));
    const ack = await serial.read(1);
    if (ack[0] !== 0x06) throw new Error("No ACK");

    const img = await serial.read(2048);
    this.load(img, 0);

    this.dispatch_progress(1);
  }

  override async write() {
    if (!this._img) throw new Error("No data");
    const img = Buffer.from(this._img);

    this.dispatch_progress(0);

    await serial.begin({ baudRate: 9600 });
    await serial.clear();

    // TODO: Реализуй запись в станцию. Не забудь про this.dispatch_progress(...);
    await serial.write(Buffer.from([0x03, 0x04]));
    await serial.write(img);

    this.dispatch_progress(1);
  }
}

```